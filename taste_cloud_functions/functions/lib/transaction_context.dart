import 'package:taste_cloud_functions/taste_functions.dart';

/// TransactionContext provides utilities and access to data *specific* to a
/// `Call` Cloud Function request.
///
/// Every TransactionContext should exist within a particular `transaction`, so
/// all data mutations should be passed through the `transaction`, rather than
/// through the `tc` global method. Otherwise, you lose the safety provided by
/// the transaction.
///
/// This class contains many utilities which simplify the handling of actions
/// from the client, such as:
/// * a handle to the `user` `DocumentReference`,
/// * generating document references idempotent to this context,
/// * accessing user permissions,
/// * Retrieving snapshots to references passed by the client, and guaranteeing
///   its existence and its type safety.
/// * etc...
class TransactionContext {
  /// A forwarded handle to the original `context` provided by the Cloud
  /// Function framework.
  final CallableContext context;

  /// The data passed by the user.
  final Map<String, dynamic> data;

  /// The current transaction.  Use this member to make modifications to the DB.
  final BatchedTransaction transaction;
  DocumentReference get user => buildType.isTest
      ? _testUser
      : CollectionType.users.coll.document(context.authUid);
  DocumentReference get _testUser =>
      CollectionType.users.coll.document(_testUserId);
  final String _testUserId;

  TransactionContext(
      this.context, this.data, this.transaction, this._testUserId) {
    if (buildType.isTest) {
      if (_testUserId == null) {
        throw Exception('Test User is null!!!!!');
      }
    }
  }

  Future<TasteUser> get tasteUser async =>
      TasteUsers.make(await user.tGet(transaction), transaction);

  /// Converts a `TransactionFn` callback into `CloudFn`, which can be passed to
  /// the `functions` registration mechanism.
  ///
  /// A `CloudFn` is a function definition which can be directly registered with
  /// Firebase Cloud Functions. It's the lowest-level API for doing so. If you
  /// need to create a new cloud-function endpoint, you need to give Firebase a
  /// `CloudFn` instance, and associate it with a unique name. Clients use this
  /// unique name you choose to call your cloud functions from the client code.
  ///
  /// A `TransactionFn` is conceptually the same as `CloudFn`, except that a
  /// `TransactionFn` assumes that common set-up and tear-down best practices
  /// are performed before and after calling the `TransactionFn`.
  ///
  /// For instance, while a `CloudFn` execution makes no assumptions about a
  /// transaction being used, a `TransactionFn` has access to a `Transaction`
  /// object within the `TransactionContext` that's passed to the function.
  /// Using transactions is a convention that we wish to establish across all
  /// our cloud functions, so it's recommended that all `CloudFn`'s are defined
  /// via a `TransactionFn` that is "wrapped" by this `wrap` method.
  ///
  /// I.e., this converts from our `specialized` context to the one expected by
  /// the Cloud Functions framework.
  ///
  /// This method does the work of calling the `onCall` method, generating a
  /// transaction to work within, running the `TransactionFn` `fn`, handling
  /// errors generated by `fn`, and wrapping the result in a `Status` to return
  /// to the user.
  static HttpsFunction wrap(TransactionFn transactionFn) {
    return functions
        .runWith(RuntimeOptions(timeoutSeconds: 540, memory: '2GB'))
        .https
        .onCall((userData, callableContext) async {
      final startTime = DateTime.now();
      final fn = tasteFnByName(userData['fn'] as String) ?? transactionFn;
      final metadata =
          Map<String, dynamic>.from(userData['metadata'] as Map ?? {});
      userData = userData['payload'] ?? userData;
      // Create the transaction that will be passed to `TransactionContext`.
      final start = structuredLog(
        fn,
        callableContext.eventId,
        'call-start',
        {'user': callableContext.authUid, 'user-data': userData},
        Map.from(metadata),
      );
      final response = await BatchedTransaction.batchedTransaction(
          callableContext.eventId, (transaction) async {
        // The status value, returned to the user.
        Status responseStatus;
        try {
          // Create a specialized context for this transaction, while also
          // converting the `dynamic` `userData` into the convenient
          // `RequestMap` form.
          final testUserId = userData['__test_user__'] as String;
          final callContext = TransactionContext(
              callableContext,
              Map.from(userData as Map)..remove('__test_user__'),
              transaction,
              testUserId);
          // Call the actual `TransactionFn` within the context of this
          // transaction,
          final callFnResult = await fn(callContext) ?? true;
          // Coerce the return type of `fn` into a standardized `Status` format
          // to have a consistent return-type for all client calls.
          responseStatus = Status.wrap(callFnResult);
        } on CloudFnException catch (e) {
          print('cloud fn error ${e.message}');
          responseStatus = Status.fromCloudFnException(e);
        } catch (e, s) {
          print('Unexpected error $e\n\n$s');
          // Do not return the error message for non-CloudFnException types.
          responseStatus = Status.fail('Unexpected error');
        }
        // The return-value must be json-able, so convert the `Status` object
        // before returning.
        return responseStatus.toMap;
      });
      final end = structuredLog(
        fn,
        callableContext.eventId,
        'call-end',
        {
          'user': callableContext.authUid,
          'response': response,
          'milliseconds': DateTime.now().difference(startTime).inMilliseconds
        },
        metadata,
      );
      await [start, end].wait;
      return response;
    });
  }
}

/// Shorthand for a function-handle that defines the business logic of a call-
/// type cloud function, within the context of a transaction, see
/// `TransactionContext` for more.
typedef TransactionFn<T> = Future<T> Function(TransactionContext context);

/// Creates an `call` Firebase cloud-function from `fn`.
HttpsFunction callFn(TransactionFn fn) => TransactionContext.wrap(fn);
HttpsFunction registerCallFn(TransactionFn fn, String name) {
  final cloudFn = callFn(fn);
  if (name == 'tasteCall') {
    registerFunction(name, fn, cloudFn);
  } else {
    fnRegistry[fn] = name;
  }
  return cloudFn;
}
